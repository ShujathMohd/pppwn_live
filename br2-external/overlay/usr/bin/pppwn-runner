#!/bin/sh

# Wait for network interface
while [ ! -f /tmp/pppwn_interface ]; do
    sleep 1
done

INTERFACE=$(cat /tmp/pppwn_interface)
echo "Using interface: $INTERFACE"

# Run PPPwn exploit
echo "Starting PPPwn exploit..."
/usr/bin/pppwn -i "$INTERFACE" --fw 1100 --stage1 /usr/share/pppwn/stage1.bin --stage2 /usr/share/pppwn/stage2.bin

if [ $? -eq 0 ]; then
    echo "PPPwn completed successfully!"
    sleep 5
    poweroff
else
    echo "PPPwn failed, retrying in 10 seconds..."
    sleep 10
    exec "$0"
fi

show_progress() {
    local step="$1"
    local total="$2"
    local description="$3"
    
    if [ "$progress_indicators" = "true" ]; then
        local percent=$((step * 100 / total))
        printf "\r[%3d%%] %s" "$percent" "$description"
        if [ "$step" -eq "$total" ]; then
            echo  # New line when complete
        fi
    else
        show_status "INFO" "$description"
    fi
}

# Function to check prerequisites
check_prerequisites() {
    show_progress 1 5 "Checking system prerequisites..."
    
    # Check if PPPwn binary exists
    if [ ! -x "$BINARY_PATH" ]; then
        show_status "ERROR" "PPPwn binary not found at $BINARY_PATH"
        /usr/bin/error-handler report E007 "" "Binary path: $BINARY_PATH"
        return 1
    fi
    
    # Check if stage files exist
    if [ ! -d "$STAGE1_PATH" ] || [ ! -d "$STAGE2_PATH" ]; then
        show_status "ERROR" "PPPwn stage files not found"
        show_status "INFO" "Expected: $STAGE1_PATH and $STAGE2_PATH"
        /usr/bin/error-handler report E008 "" "Stage1: $STAGE1_PATH, Stage2: $STAGE2_PATH"
        return 1
    fi
    
    # Check for network interface
    if [ ! -f /tmp/pppwn_interface ]; then
        show_status "ERROR" "No network interface configured"
        show_status "INFO" "Network detection may have failed"
        /usr/bin/error-handler report E012 "Network interface not configured" "Interface file: /tmp/pppwn_interface"
        return 1
    fi
    
    show_progress 2 5 "Prerequisites check complete"
    return 0
}

# Function to detect firmware version automatically
detect_firmware_version() {
    show_status "INFO" "Attempting to detect PS4 firmware version..."
    
    # Try to detect firmware version from network traffic or user input
    # For now, use configured version but allow override
    local detected_version="$FIRMWARE_VERSION"
    
    # Check if user provided firmware version via kernel parameter
    if grep -q "pppwn.fw=" /proc/cmdline; then
        detected_version=$(grep -o 'pppwn\.fw=[0-9]*' /proc/cmdline | cut -d= -f2)
        show_status "INFO" "Firmware version override from boot parameter: $detected_version"
    fi
    
    # Validate firmware version format (should be 4 digits)
    if echo "$detected_version" | grep -qE '^[0-9]{4}$'; then
        FIRMWARE_VERSION="$detected_version"
        show_status "INFO" "Using firmware version: $FIRMWARE_VERSION"
        return 0
    else
        show_status "WARNING" "Invalid firmware version format: $detected_version"
        show_status "INFO" "Using default firmware version: $FIRMWARE_VERSION"
        /usr/bin/error-handler report W004 "Invalid firmware version format, using default" "Detected: $detected_version, Default: $FIRMWARE_VERSION"
        return 0
    fi
}

# Function to find best matching stage files
find_stage_files() {
    local fw_version="$1"
    local stage1_found=""
    local stage2_found=""
    
    # Priority order for stage file matching:
    # 1. Exact firmware version match
    # 2. Generic stage files
    # 3. Any available stage files
    
    # Look for stage1 files
    for pattern in "${fw_version}" "stage1" "*"; do
        for stage1 in "$STAGE1_PATH"/*"$pattern"*.bin "$STAGE1_PATH"/"$pattern".bin; do
            if [ -f "$stage1" ]; then
                stage1_found="$stage1"
                break 2
            fi
        done
    done
    
    # Look for stage2 files
    for pattern in "${fw_version}" "stage2" "*"; do
        for stage2 in "$STAGE2_PATH"/*"$pattern"*.bin "$STAGE2_PATH"/"$pattern".bin; do
            if [ -f "$stage2" ]; then
                stage2_found="$stage2"
                break 2
            fi
        done
    done
    
    STAGE1_FILE="$stage1_found"
    STAGE2_FILE="$stage2_found"
    
    if [ -n "$STAGE1_FILE" ] && [ -n "$STAGE2_FILE" ]; then
        return 0
    else
        return 1
    fi
}

# Function to prepare exploit execution
prepare_exploit() {
    show_progress 3 5 "Preparing exploit execution..."
    
    # Read configured interface
    INTERFACE=$(cat /tmp/pppwn_interface 2>/dev/null)
    if [ -z "$INTERFACE" ]; then
        show_status "ERROR" "Could not determine network interface"
        /usr/bin/error-handler report E002 "Could not read network interface configuration" "Interface file: /tmp/pppwn_interface"
        return 1
    fi
    
    show_status "INFO" "Using network interface: $INTERFACE"
    
    # Detect firmware version
    detect_firmware_version
    
    # Find appropriate stage files
    if find_stage_files "$FIRMWARE_VERSION"; then
        show_status "INFO" "Using stage1: $(basename "$STAGE1_FILE")"
        show_status "INFO" "Using stage2: $(basename "$STAGE2_FILE")"
    else
        show_status "ERROR" "Could not find stage files for firmware $FIRMWARE_VERSION"
        show_status "INFO" "Available stage1 files:"
        ls -la "$STAGE1_PATH" 2>/dev/null || echo "  (none found)"
        show_status "INFO" "Available stage2 files:"
        ls -la "$STAGE2_PATH" 2>/dev/null || echo "  (none found)"
        /usr/bin/error-handler report E008 "Stage files not found for firmware version" "Firmware: $FIRMWARE_VERSION, Stage1: $STAGE1_PATH, Stage2: $STAGE2_PATH"
        return 1
    fi
    
    show_progress 4 5 "Exploit preparation complete"
    return 0
}

# Function to provide user guidance before exploit execution
show_exploit_guidance() {
    echo
    /usr/bin/status-display guidance "PPPwn Exploit Execution" \
        "Ensure PS4 is connected via Ethernet cable" \
        "Verify PS4 is running firmware version $FIRMWARE_VERSION" \
        "Confirm PS4 is powered on and at the main menu" \
        "Ensure no other devices are on this network interface" \
        "Be patient - the process may take several attempts"
    
    show_status "INFO" "The exploit will now attempt to jailbreak your PS4..."
    show_status "INFO" "Multiple attempts are normal and expected"
    echo
}

# Function to monitor PPPwn execution with real-time updates
monitor_pppwn_execution() {
    local pppwn_cmd="$1"
    local attempt="$2"
    
    /usr/bin/status-display realtime "Exploit" "Starting execution" "attempt $attempt"
    show_status "DEBUG" "Command: $pppwn_cmd"
    echo
    
    # Create a temporary file to capture output
    local output_file="/tmp/pppwn_output_$$"
    local pid_file="/tmp/pppwn_pid_$$"
    
    # Start PPPwn in background and capture its PID
    ($pppwn_cmd 2>&1 | tee "$output_file") &
    local pppwn_pid=$!
    echo "$pppwn_pid" > "$pid_file"
    
    # Monitor execution with timeout
    local elapsed=0
    local last_output_size=0
    local status_interval=10
    local last_status_time=0
    
    /usr/bin/status-display realtime "Exploit" "Initializing" "connecting to PS4"
    
    while [ $elapsed -lt $TIMEOUT_SECONDS ]; do
        if ! kill -0 "$pppwn_pid" 2>/dev/null; then
            # Process has finished
            wait "$pppwn_pid"
            local exit_code=$?
            rm -f "$pid_file" "$output_file"
            return $exit_code
        fi
        
        # Show progress update every 10 seconds
        if [ $((elapsed % status_interval)) -eq 0 ] && [ $elapsed -gt $last_status_time ]; then
            local current_size=$(wc -l < "$output_file" 2>/dev/null || echo 0)
            local progress_percent=$((elapsed * 100 / TIMEOUT_SECONDS))
            
            if [ "$current_size" -gt "$last_output_size" ]; then
                /usr/bin/status-display realtime "Exploit" "Active communication" "${elapsed}s elapsed, ${progress_percent}% timeout"
                last_output_size=$current_size
            else
                /usr/bin/status-display realtime "Exploit" "Waiting for PS4" "${elapsed}s elapsed, ${progress_percent}% timeout"
            fi
            last_status_time=$elapsed
        fi
        
        sleep 1
        elapsed=$((elapsed + 1))
    done
    
    # Timeout reached, kill the process
    /usr/bin/status-display realtime "Exploit" "Timeout reached" "terminating process"
    kill -TERM "$pppwn_pid" 2>/dev/null
    sleep 2
    kill -KILL "$pppwn_pid" 2>/dev/null
    
    # Mark timeout for potential shutdown handling
    echo "EXPLOIT_TIMEOUT" > /tmp/pppwn_timeout
    
    rm -f "$pid_file" "$output_file"
    return 124  # Timeout exit code
}

# Function to execute PPPwn exploit
execute_exploit() {
    show_progress 5 5 "Starting PPPwn exploit execution..."
    
    # Show user guidance
    show_exploit_guidance
    
    local attempt=1
    local success=false
    
    while [ $attempt -le $RETRY_ATTEMPTS ] && [ "$success" = "false" ]; do
        echo "----------------------------------------"
        show_status "INFO" "Exploit attempt $attempt of $RETRY_ATTEMPTS"
        show_status "INFO" "Target: PS4 Firmware $FIRMWARE_VERSION"
        show_status "INFO" "Interface: $INTERFACE"
        show_status "INFO" "Stage1: $(basename "$STAGE1_FILE")"
        show_status "INFO" "Stage2: $(basename "$STAGE2_FILE")"
        echo
        
        # Build PPPwn command
        local pppwn_cmd="$BINARY_PATH -i $INTERFACE --fw $FIRMWARE_VERSION --stage1 $STAGE1_FILE --stage2 $STAGE2_FILE"
        
        if [ "$AUTO_MODE" = "true" ]; then
            pppwn_cmd="$pppwn_cmd -a"
        fi
        
        # Add verbose output if configured
        if [ "$verbose_output" = "true" ]; then
            pppwn_cmd="$pppwn_cmd -v"
        fi
        
        # Execute PPPwn with monitoring
        monitor_pppwn_execution "$pppwn_cmd" "$attempt"
        local exit_code=$?
        
        echo
        
        case $exit_code in
            0)
                show_status "SUCCESS" "PPPwn exploit completed successfully!"
                show_status "SUCCESS" "Your PS4 has been jailbroken!"
                /usr/bin/error-handler report I005 "PPPwn exploit completed successfully" "Attempt: $attempt, Firmware: $FIRMWARE_VERSION, Interface: $INTERFACE"
                success=true
                ;;
            124)
                show_status "WARNING" "PPPwn execution timed out after $TIMEOUT_SECONDS seconds"
                show_status "INFO" "This may happen if the PS4 is not responding or network issues occur"
                /usr/bin/error-handler report W008 "PPPwn execution timeout" "Timeout: ${TIMEOUT_SECONDS}s, Attempt: $attempt"
                ;;
            1)
                show_status "ERROR" "PPPwn execution failed - exploit unsuccessful"
                show_status "INFO" "This is normal and may require multiple attempts"
                /usr/bin/error-handler report W005 "PPPwn exploit attempt failed" "Attempt: $attempt/$RETRY_ATTEMPTS, Exit code: $exit_code"
                ;;
            2)
                show_status "ERROR" "PPPwn execution failed - network or hardware error"
                show_status "INFO" "Check your network connection and PS4 status"
                /usr/bin/error-handler report E010 "PPPwn network/hardware error" "Attempt: $attempt, Interface: $INTERFACE, Exit code: $exit_code"
                ;;
            *)
                show_status "ERROR" "PPPwn execution failed with exit code $exit_code"
                show_status "INFO" "Check system logs for more details"
                /usr/bin/error-handler report E010 "PPPwn execution failed with unknown exit code" "Exit code: $exit_code, Attempt: $attempt"
                ;;
        esac
        
        if [ "$success" = "false" ] && [ $attempt -lt $RETRY_ATTEMPTS ]; then
            echo
            show_status "INFO" "Preparing for retry attempt..."
            show_status "INFO" "Waiting $RETRY_DELAY seconds before next attempt..."
            
            # Countdown for retry delay
            for i in $(seq $RETRY_DELAY -1 1); do
                printf "\rRetrying in %d seconds... " "$i"
                sleep 1
            done
            echo
        fi
        
        attempt=$((attempt + 1))
    done
    
    if [ "$success" = "true" ]; then
        return 0
    else
        return 1
    fi
}

# Function to handle post-execution
handle_completion() {
    local success="$1"
    
    echo
    
    if [ "$success" = "true" ]; then
        /usr/bin/status-display success "PPPwn Exploit Completed Successfully!" \
            "Your PS4 has been jailbroken and is ready for homebrew installation. You can now install packages, run homebrew applications, and access advanced PS4 features."
        
        if [ "$AUTO_SHUTDOWN" = "true" ]; then
            echo
            show_status "SUCCESS" "Exploit completed successfully!"
            show_status "INFO" "Initiating secure shutdown sequence..."
            
            # Use secure shutdown script for success scenario
            /usr/bin/secure-shutdown success "PPPwn exploit completed successfully"
        else
            echo
            show_status "INFO" "Exploit completed successfully!"
            show_status "INFO" "You can now safely disconnect and use your jailbroken PS4"
        fi
    else
        local troubleshooting="Check Ethernet cable connection between PS4 and this system. Verify PS4 firmware version matches $FIRMWARE_VERSION. Try restarting both PS4 and this system. Ensure PS4 is at main menu and not in rest mode."
        
        /usr/bin/status-display error "PPPwn Exploit Failed" \
            "The exploit was unable to successfully jailbreak your PS4 after $RETRY_ATTEMPTS attempts. This can happen due to network issues, firmware mismatches, or timing problems." \
            "$troubleshooting"
        
        if [ "$AUTO_SHUTDOWN" = "true" ]; then
            echo
            show_status "ERROR" "Exploit failed after all attempts"
            show_status "INFO" "Initiating error shutdown sequence..."
            
            # Use secure shutdown script for error scenario
            /usr/bin/secure-shutdown error "PPPwn exploit failed after $RETRY_ATTEMPTS attempts"
        else
            echo
            show_status "INFO" "Press Enter to access emergency shell for manual troubleshooting..."
            read
        fi
    fi
}

# Function to handle errors and cleanup
cleanup_and_exit() {
    local exit_code="$1"
    
    # Check if we should trigger timeout shutdown
    if [ -f /tmp/pppwn_timeout ] && [ "$AUTO_SHUTDOWN" = "true" ]; then
        show_status "WARNING" "Multiple timeouts detected - initiating timeout shutdown"
        /usr/bin/secure-shutdown timeout "Multiple exploit timeouts detected"
        return
    fi
    
    # Clear sensitive data if configured (basic cleanup for non-shutdown exits)
    if [ "$clear_memory_on_shutdown" = "true" ]; then
        show_status "INFO" "Clearing sensitive data from memory..."
        # Use security hardening script for thorough cleanup
        if command -v security-hardening >/dev/null 2>&1; then
            /usr/bin/security-hardening clear-memory
        else
            # Fallback to basic cleanup
            history -c 2>/dev/null
            rm -f /tmp/pppwn_* 2>/dev/null
            sync
        fi
    fi
    
    exit "$exit_code"
}

# Global timeout handler
global_timeout_handler() {
    show_status "WARNING" "Global execution timeout reached"
    if [ "$AUTO_SHUTDOWN" = "true" ]; then
        /usr/bin/secure-shutdown timeout "Global execution timeout exceeded"
    else
        cleanup_and_exit 124
    fi
}

# Signal handlers
trap 'show_status "INFO" "Interrupt received, cleaning up..."; cleanup_and_exit 130' INT TERM
trap 'global_timeout_handler' ALRM

# Main execution function
main() {
    # Set up global timeout (total execution time limit)
    local global_timeout=$((TIMEOUT_SECONDS * RETRY_ATTEMPTS + 300))  # Extra buffer time
    (sleep "$global_timeout" && kill -ALRM $$ 2>/dev/null) &
    local timeout_pid=$!
    
    # Clear screen if configured
    if [ "$clear_screen" = "true" ]; then
        clear
    fi
    
    # Show banner if configured (already shown by profile.d script)
    if [ "$show_banner" = "true" ] && [ "$(tty)" != "/dev/tty1" ]; then
        echo "PPPwn Live System - Exploit Runner"
        echo "=================================="
        echo
    fi
    
    # Check for previous errors
    if [ -f /tmp/pppwn_error ]; then
        local error_type=$(cat /tmp/pppwn_error)
        case "$error_type" in
            "NETWORK_DETECTION_FAILED")
                show_status "ERROR" "Network detection failed during system startup"
                show_status "INFO" "Please check your Ethernet connection and restart the system"
                /usr/bin/error-handler report E001 "Network detection failed during startup" "Error type: $error_type"
                ;;
            *)
                show_status "ERROR" "System startup error: $error_type"
                /usr/bin/error-handler report E012 "System startup error detected" "Error type: $error_type"
                ;;
        esac
        echo
        show_status "INFO" "Recovery options available:"
        show_status "INFO" "1. Press 'r' for recovery system"
        show_status "INFO" "2. Press 'e' for emergency shell"
        show_status "INFO" "3. Press Enter to continue anyway"
        printf "Choice: "
        read recovery_choice
        
        case "$recovery_choice" in
            [Rr])
                if [ -x /usr/bin/recovery-system ]; then
                    /usr/bin/recovery-system
                else
                    show_status "ERROR" "Recovery system not available"
                    /usr/bin/emergency-shell
                fi
                cleanup_and_exit 1
                ;;
            [Ee])
                /usr/bin/emergency-shell
                cleanup_and_exit 1
                ;;
            *)
                show_status "INFO" "Continuing with current configuration..."
                ;;
        esac
    fi
    
    # Execute main workflow
    if check_prerequisites && prepare_exploit; then
        if execute_exploit; then
            handle_completion "true"
        else
            handle_completion "false"
        fi
    else
        show_status "ERROR" "System prerequisites not met"
        show_status "INFO" "Launching recovery system for troubleshooting..."
        
        # Offer recovery options
        if [ "$AUTO_SHUTDOWN" != "true" ]; then
            echo
            show_status "INFO" "Recovery options:"
            show_status "INFO" "1. Launch recovery system (recommended)"
            show_status "INFO" "2. Access emergency shell"
            show_status "INFO" "3. Continue to shutdown"
            printf "Choice (1-3): "
            read recovery_choice
            
            case "$recovery_choice" in
                1)
                    if [ -x /usr/bin/recovery-system ]; then
                        /usr/bin/recovery-system
                    else
                        /usr/bin/emergency-shell
                    fi
                    ;;
                2)
                    /usr/bin/emergency-shell
                    ;;
                *)
                    show_status "INFO" "Proceeding to shutdown..."
                    ;;
            esac
        fi
        
        handle_completion "false"
    fi
    
    # Clean up timeout process
    kill "$timeout_pid" 2>/dev/null
    
    cleanup_and_exit 0
}

# Execute main function
main "$@"