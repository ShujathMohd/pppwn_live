#!/bin/sh
#
# Status Display Utility for PPPwn Live System
# Provides formatted status output and user guidance
#

# Configuration
COLOR_OUTPUT="${color_output:-true}"
VERBOSE_OUTPUT="${verbose_output:-true}"

# Color definitions
if [ "$COLOR_OUTPUT" = "true" ]; then
    RED='\033[1;31m'
    GREEN='\033[1;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[1;34m'
    CYAN='\033[1;36m'
    WHITE='\033[1;37m'
    RESET='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    CYAN=''
    WHITE=''
    RESET=''
fi

# Status display function
show_status() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%H:%M:%S')
    
    case "$level" in
        "INFO")
            printf "${BLUE}[INFO]${RESET} ${WHITE}%s${RESET} %s\n" "$timestamp" "$message"
            ;;
        "SUCCESS")
            printf "${GREEN}[SUCCESS]${RESET} ${WHITE}%s${RESET} %s\n" "$timestamp" "$message"
            ;;
        "ERROR")
            printf "${RED}[ERROR]${RESET} ${WHITE}%s${RESET} %s\n" "$timestamp" "$message"
            ;;
        "WARNING")
            printf "${YELLOW}[WARNING]${RESET} ${WHITE}%s${RESET} %s\n" "$timestamp" "$message"
            ;;
        "DEBUG")
            if [ "$VERBOSE_OUTPUT" = "true" ]; then
                printf "${CYAN}[DEBUG]${RESET} ${WHITE}%s${RESET} %s\n" "$timestamp" "$message"
            fi
            ;;
        *)
            printf "[%s] ${WHITE}%s${RESET} %s\n" "$level" "$timestamp" "$message"
            ;;
    esac
}

# Progress bar function
show_progress() {
    local current="$1"
    local total="$2"
    local description="$3"
    local width=50
    
    local percent=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    printf "\r${BLUE}[%3d%%]${RESET} [" "$percent"
    
    # Draw filled portion
    for i in $(seq 1 $filled); do
        printf "${GREEN}█${RESET}"
    done
    
    # Draw empty portion
    for i in $(seq 1 $empty); do
        printf "${WHITE}░${RESET}"
    done
    
    printf "] %s" "$description"
    
    if [ "$current" -eq "$total" ]; then
        echo  # New line when complete
    fi
}

# Spinner function for ongoing operations
show_spinner() {
    local pid="$1"
    local message="$2"
    local spin_chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
    local i=0
    
    while kill -0 "$pid" 2>/dev/null; do
        local char=$(echo "$spin_chars" | cut -c$((i % 10 + 1)))
        printf "\r${CYAN}%s${RESET} %s" "$char" "$message"
        sleep 0.1
        i=$((i + 1))
    done
    
    printf "\r${GREEN}✓${RESET} %s\n" "$message"
}

# Banner display function
show_banner() {
    clear
    echo -e "${BLUE}▗▄▄▖ ${CYAN}▗▄▄▖ ${BLUE}▗▄▄▖ ${WHITE}▗▖ ${WHITE}▗▖${BLUE}▗▖  ${CYAN}▗▖▗▖   ${BLUE}▗▄▄▄▖${WHITE}▗▖  ${BLUE}▗▖${WHITE}▗▄▄▄▖${RESET}"
    echo -e "${BLUE}▐▌ ▐▌${CYAN}▐▌ ▐▌${BLUE}▐▌ ▐▌${WHITE}▐▌ ▐▌${CYAN}▐▛▚▖${BLUE}▐▌${WHITE}▐▌     ${BLUE}█  ${WHITE}▐▌  ${BLUE}▐▌${WHITE}▐▌   ${RESET}"
    echo -e "${BLUE}▐▛▀▘ ${CYAN}▐▛▀▘ ${BLUE}▐▛▀▘ ${WHITE}▐▌ ▐▌${CYAN}▐▌ ▝▜▌${WHITE}▐▌     ${BLUE}█  ${WHITE}▐▌  ${BLUE}▐▛▀▀▘${RESET}"
    echo -e "${BLUE}▐▌   ${CYAN}▐▌   ${BLUE}▐▌   ${WHITE}▐▙█▟▌${CYAN}▐▌  ▐▌${BLUE}▐▙▄▄▖${WHITE}▗▄█▄▖ ${CYAN}▝▚▞▘ ${BLUE}▐▙▄▄▖${RESET}"
    echo
}

# System information display
show_system_info() {
    echo -e "${WHITE}System Information:${RESET}"
    echo -e "  Hostname: ${CYAN}$(hostname)${RESET}"
    echo -e "  Kernel: ${CYAN}$(uname -r)${RESET}"
    echo -e "  Uptime: ${CYAN}$(uptime | cut -d',' -f1 | cut -d' ' -f4-)${RESET}"
    
    # Network interfaces
    echo -e "  Network Interfaces:"
    for iface in /sys/class/net/*; do
        if [ -d "$iface" ]; then
            iface_name=$(basename "$iface")
            if [ "$iface_name" != "lo" ]; then
                local status="DOWN"
                if [ -f "$iface/carrier" ]; then
                    carrier=$(cat "$iface/carrier" 2>/dev/null)
                    if [ "$carrier" = "1" ]; then
                        status="UP"
                    fi
                fi
                
                local ip_addr=$(ip addr show "$iface_name" 2>/dev/null | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)
                if [ -n "$ip_addr" ]; then
                    echo -e "    ${CYAN}$iface_name${RESET}: $status (${GREEN}$ip_addr${RESET})"
                else
                    echo -e "    ${CYAN}$iface_name${RESET}: $status"
                fi
            fi
        fi
    done
    echo
}

# Success message with celebration
show_success_message() {
    local title="$1"
    local message="$2"
    
    echo
    echo -e "${GREEN}╔══════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${GREEN}║                         SUCCESS!                             ║${RESET}"
    echo -e "${GREEN}╠══════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${GREEN}║${RESET} ${WHITE}$title${RESET}$(printf "%*s" $((58 - ${#title})) "")${GREEN}║${RESET}"
    if [ -n "$message" ]; then
        echo -e "${GREEN}║${RESET}                                                              ${GREEN}║${RESET}"
        # Word wrap the message
        echo "$message" | fold -s -w 58 | while IFS= read -r line; do
            echo -e "${GREEN}║${RESET} $line$(printf "%*s" $((58 - ${#line})) "")${GREEN}║${RESET}"
        done
    fi
    echo -e "${GREEN}╚══════════════════════════════════════════════════════════════╝${RESET}"
    echo
}

# Error message with troubleshooting
show_error_message() {
    local title="$1"
    local message="$2"
    local suggestions="$3"
    
    echo
    echo -e "${RED}╔══════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${RED}║                          ERROR!                              ║${RESET}"
    echo -e "${RED}╠══════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${RED}║${RESET} ${WHITE}$title${RESET}$(printf "%*s" $((58 - ${#title})) "")${RED}║${RESET}"
    if [ -n "$message" ]; then
        echo -e "${RED}║${RESET}                                                              ${RED}║${RESET}"
        echo "$message" | fold -s -w 58 | while IFS= read -r line; do
            echo -e "${RED}║${RESET} $line$(printf "%*s" $((58 - ${#line})) "")${RED}║${RESET}"
        done
    fi
    
    if [ -n "$suggestions" ]; then
        echo -e "${RED}║${RESET}                                                              ${RED}║${RESET}"
        echo -e "${RED}║${RESET} ${YELLOW}Troubleshooting Suggestions:${RESET}$(printf "%*s" $((32)) "")${RED}║${RESET}"
        echo "$suggestions" | fold -s -w 58 | while IFS= read -r line; do
            echo -e "${RED}║${RESET} • $line$(printf "%*s" $((56 - ${#line})) "")${RED}║${RESET}"
        done
    fi
    echo -e "${RED}╚══════════════════════════════════════════════════════════════╝${RESET}"
    echo
}

# Real-time status update with timestamp
show_realtime_status() {
    local phase="$1"
    local status="$2"
    local details="$3"
    local timestamp=$(date '+%H:%M:%S')
    
    printf "${CYAN}[%s]${RESET} ${WHITE}%s:${RESET} %s" "$timestamp" "$phase" "$status"
    if [ -n "$details" ]; then
        printf " ${BLUE}(%s)${RESET}" "$details"
    fi
    echo
}

# Animated waiting indicator
show_waiting() {
    local message="$1"
    local duration="${2:-30}"
    local spin_chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
    
    for i in $(seq 1 $duration); do
        local char_index=$((i % 10))
        local char=$(echo "$spin_chars" | cut -c$((char_index + 1)))
        printf "\r${CYAN}%s${RESET} %s ${BLUE}(%ds)${RESET}" "$char" "$message" "$i"
        sleep 1
    done
    echo
}

# User guidance display
show_user_guidance() {
    local phase="$1"
    shift
    local instructions="$@"
    
    echo
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${BLUE}║                      USER GUIDANCE                           ║${RESET}"
    echo -e "${BLUE}╠══════════════════════════════════════════════════════════════╣${RESET}"
    echo -e "${BLUE}║${RESET} ${WHITE}Phase: $phase${RESET}$(printf "%*s" $((51 - ${#phase})) "")${BLUE}║${RESET}"
    echo -e "${BLUE}║${RESET}                                                              ${BLUE}║${RESET}"
    
    local step=1
    for instruction in "$@"; do
        echo -e "${BLUE}║${RESET} ${YELLOW}$step.${RESET} $instruction$(printf "%*s" $((55 - ${#instruction})) "")${BLUE}║${RESET}"
        step=$((step + 1))
    done
    
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${RESET}"
    echo
}

# Help display
show_help() {
    echo "PPPwn Live System - Status Display Utility"
    echo
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo
    echo "Commands:"
    echo "  status LEVEL MESSAGE       - Display status message"
    echo "  progress CURRENT TOTAL DESC - Show progress bar"
    echo "  success TITLE [MESSAGE]    - Show success message"
    echo "  error TITLE MESSAGE [SUGGESTIONS] - Show error message"
    echo "  realtime PHASE STATUS [DETAILS] - Real-time status update"
    echo "  waiting MESSAGE [DURATION] - Show waiting indicator"
    echo "  guidance PHASE INSTRUCTION... - Show user guidance"
    echo "  banner                     - Display PPPwn banner"
    echo "  sysinfo                    - Show system information"
    echo "  help                       - Show this help"
    echo
    echo "Status Levels: INFO, SUCCESS, ERROR, WARNING, DEBUG"
    echo
    echo "Examples:"
    echo "  $0 status INFO 'Starting network detection'"
    echo "  $0 progress 3 10 'Configuring network'"
    echo "  $0 success 'Exploit Complete' 'PS4 successfully jailbroken'"
    echo "  $0 error 'Network Failed' 'No interface found' 'Check cables'"
    echo "  $0 guidance 'Preparation' 'Connect PS4' 'Power on console'"
}

# Main execution
case "$1" in
    "status")
        if [ $# -ge 3 ]; then
            show_status "$2" "$3"
        else
            echo "Usage: $0 status LEVEL MESSAGE"
            exit 1
        fi
        ;;
    "progress")
        if [ $# -ge 4 ]; then
            show_progress "$2" "$3" "$4"
        else
            echo "Usage: $0 progress CURRENT TOTAL DESCRIPTION"
            exit 1
        fi
        ;;
    "success")
        if [ $# -ge 2 ]; then
            show_success_message "$2" "$3"
        else
            echo "Usage: $0 success TITLE [MESSAGE]"
            exit 1
        fi
        ;;
    "error")
        if [ $# -ge 3 ]; then
            show_error_message "$2" "$3" "$4"
        else
            echo "Usage: $0 error TITLE MESSAGE [SUGGESTIONS]"
            exit 1
        fi
        ;;
    "realtime")
        if [ $# -ge 3 ]; then
            show_realtime_status "$2" "$3" "$4"
        else
            echo "Usage: $0 realtime PHASE STATUS [DETAILS]"
            exit 1
        fi
        ;;
    "waiting")
        if [ $# -ge 2 ]; then
            show_waiting "$2" "$3"
        else
            echo "Usage: $0 waiting MESSAGE [DURATION]"
            exit 1
        fi
        ;;
    "guidance")
        if [ $# -ge 3 ]; then
            shift
            show_user_guidance "$@"
        else
            echo "Usage: $0 guidance PHASE INSTRUCTION..."
            exit 1
        fi
        ;;
    "banner")
        show_banner
        ;;
    "sysinfo")
        show_system_info
        ;;
    "help"|"--help"|"-h")
        show_help
        ;;
    "")
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        echo "Use '$0 help' for usage information"
        exit 1
        ;;
esac