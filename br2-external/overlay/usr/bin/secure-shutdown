#!/bin/sh
#
# Secure Shutdown Script for PPPwn Live System
# Implements secure shutdown sequence with memory clearing and data sanitization
#

# Configuration
CONFIG_FILE="/etc/pppwn/config"
SHUTDOWN_LOG="/tmp/shutdown.log"
MEMORY_CLEAR_PASSES=3
SHUTDOWN_TIMEOUT=30

# Load configuration
if [ -f "$CONFIG_FILE" ]; then
    eval $(grep -E '^[a-zA-Z_][a-zA-Z0-9_]*=' "$CONFIG_FILE" | sed 's/^/export /')
fi

# Default values
CLEAR_MEMORY_ON_SHUTDOWN="${clear_memory_on_shutdown:-true}"
AUTO_SHUTDOWN="${auto_shutdown:-true}"
VERBOSE_OUTPUT="${verbose_output:-true}"
COLOR_OUTPUT="${color_output:-true}"

# Logging function
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message" >> "$SHUTDOWN_LOG"
    
    if [ "$VERBOSE_OUTPUT" = "true" ]; then
        if [ "$COLOR_OUTPUT" = "true" ]; then
            case "$level" in
                "INFO")  echo -e "\033[1;34m[INFO]\033[0m $message" ;;
                "SUCCESS") echo -e "\033[1;32m[SUCCESS]\033[0m $message" ;;
                "ERROR") echo -e "\033[1;31m[ERROR]\033[0m $message" ;;
                "WARNING") echo -e "\033[1;33m[WARNING]\033[0m $message" ;;
                *) echo "[$level] $message" ;;
            esac
        else
            echo "[$level] $message"
        fi
    fi
    
    # Also log to system logger
    logger -t secure-shutdown "$level: $message"
}

# Function to clear sensitive data from memory
clear_sensitive_data() {
    log_message "INFO" "Starting sensitive data clearing process..."
    
    # Clear shell history
    if [ -f ~/.bash_history ]; then
        log_message "INFO" "Clearing bash history..."
        > ~/.bash_history
        history -c 2>/dev/null
    fi
    
    if [ -f ~/.ash_history ]; then
        log_message "INFO" "Clearing ash history..."
        > ~/.ash_history
    fi
    
    # Clear temporary files containing sensitive data
    log_message "INFO" "Clearing temporary files..."
    rm -f /tmp/pppwn_* 2>/dev/null
    rm -f /tmp/network_* 2>/dev/null
    rm -f /tmp/exploit_* 2>/dev/null
    rm -f /var/tmp/* 2>/dev/null
    
    # Clear system logs that might contain sensitive information
    log_message "INFO" "Clearing system logs..."
    > /var/log/messages 2>/dev/null
    > /var/log/syslog 2>/dev/null
    > /var/log/kern.log 2>/dev/null
    
    # Clear process environment variables
    log_message "INFO" "Clearing environment variables..."
    unset FIRMWARE_VERSION STAGE1_PATH STAGE2_PATH BINARY_PATH
    unset INTERFACE PS4_IP EXPLOIT_STATUS
    
    # Clear kernel ring buffer
    log_message "INFO" "Clearing kernel ring buffer..."
    dmesg -c > /dev/null 2>&1
    
    # Force memory synchronization
    log_message "INFO" "Synchronizing filesystem..."
    sync
    
    # Clear page cache, dentries and inodes (if possible)
    if [ -w /proc/sys/vm/drop_caches ]; then
        log_message "INFO" "Clearing system caches..."
        echo 3 > /proc/sys/vm/drop_caches 2>/dev/null
    fi
    
    # Use comprehensive memory clearing if available
    if [ "$CLEAR_MEMORY_ON_SHUTDOWN" = "true" ]; then
        log_message "INFO" "Performing comprehensive memory clearing..."
        if command -v clear-all-memory >/dev/null 2>&1; then
            /usr/bin/clear-all-memory
        else
            # Fallback to basic memory clearing
            log_message "INFO" "Using fallback memory clearing..."
            for pass in $(seq 1 $MEMORY_CLEAR_PASSES); do
                log_message "INFO" "Memory clearing pass $pass/$MEMORY_CLEAR_PASSES..."
                
                # Create temporary file to consume available memory
                dd if=/dev/zero of=/tmp/memory_clear bs=1M count=100 2>/dev/null || true
                rm -f /tmp/memory_clear 2>/dev/null
                
                # Brief pause between passes
                sleep 1
            done
        fi
    fi
    
    log_message "SUCCESS" "Sensitive data clearing completed"
}

# Function to terminate running processes safely
terminate_processes() {
    log_message "INFO" "Terminating running processes..."
    
    # List of processes to terminate gracefully
    local processes_to_kill="pppwn pppwn-runner network-detector status-display"
    
    for process in $processes_to_kill; do
        local pids=$(pgrep "$process" 2>/dev/null)
        if [ -n "$pids" ]; then
            log_message "INFO" "Terminating $process processes: $pids"
            kill -TERM $pids 2>/dev/null
        fi
    done
    
    # Wait for graceful termination
    sleep 3
    
    # Force kill any remaining processes
    for process in $processes_to_kill; do
        local pids=$(pgrep "$process" 2>/dev/null)
        if [ -n "$pids" ]; then
            log_message "WARNING" "Force killing $process processes: $pids"
            kill -KILL $pids 2>/dev/null
        fi
    done
    
    log_message "INFO" "Process termination completed"
}

# Function to unmount filesystems safely
unmount_filesystems() {
    log_message "INFO" "Unmounting filesystems..."
    
    # Sync all filesystems
    sync
    
    # Unmount temporary filesystems
    umount /tmp 2>/dev/null || true
    umount /var/tmp 2>/dev/null || true
    umount /dev/shm 2>/dev/null || true
    
    # Remount root filesystem as read-only if possible
    if mount -o remount,ro / 2>/dev/null; then
        log_message "INFO" "Root filesystem remounted as read-only"
    else
        log_message "WARNING" "Could not remount root filesystem as read-only"
    fi
    
    log_message "INFO" "Filesystem unmounting completed"
}

# Function to display shutdown status
show_shutdown_status() {
    local status="$1"
    local message="$2"
    
    if command -v status-display >/dev/null 2>&1; then
        /usr/bin/status-display "$status" "System Shutdown" "$message"
    else
        log_message "$status" "$message"
    fi
}

# Function to handle emergency shutdown
emergency_shutdown() {
    log_message "ERROR" "Emergency shutdown initiated"
    show_shutdown_status "error" "Emergency shutdown in progress - system will halt immediately"
    
    # Skip most cleanup in emergency mode
    sync
    halt -f
}

# Function to perform graceful shutdown
graceful_shutdown() {
    local reason="$1"
    local delay="${2:-10}"
    
    log_message "INFO" "Graceful shutdown initiated: $reason"
    show_shutdown_status "info" "System shutdown initiated: $reason"
    
    # Show countdown if delay is specified
    if [ "$delay" -gt 0 ]; then
        log_message "INFO" "Shutdown will commence in $delay seconds..."
        show_shutdown_status "info" "Shutdown countdown: $delay seconds (Press Ctrl+C to cancel)"
        
        # Countdown with interrupt handling
        local remaining=$delay
        while [ $remaining -gt 0 ]; do
            printf "\rShutdown in %d seconds... " "$remaining"
            sleep 1
            remaining=$((remaining - 1))
        done
        echo
    fi
    
    log_message "INFO" "Beginning shutdown sequence..."
    show_shutdown_status "info" "Shutdown sequence starting..."
    
    # Step 1: Terminate processes
    terminate_processes
    
    # Step 2: Clear sensitive data
    clear_sensitive_data
    
    # Step 3: Unmount filesystems
    unmount_filesystems
    
    # Step 4: Final sync and shutdown
    log_message "INFO" "Performing final system sync..."
    sync
    sync
    sync
    
    show_shutdown_status "success" "System shutdown complete - powering off"
    log_message "SUCCESS" "Secure shutdown sequence completed successfully"
    
    # Power off the system
    poweroff
}

# Function to handle timeout-based shutdown
timeout_shutdown() {
    local timeout_reason="$1"
    
    log_message "WARNING" "Timeout-based shutdown triggered: $timeout_reason"
    show_shutdown_status "warning" "System timeout detected - initiating automatic shutdown"
    
    # Shorter delay for timeout scenarios
    graceful_shutdown "timeout: $timeout_reason" 5
}

# Function to handle success-based shutdown
success_shutdown() {
    log_message "SUCCESS" "Success-based shutdown triggered"
    show_shutdown_status "success" "PPPwn exploit completed successfully - initiating shutdown"
    
    # Standard delay for success scenarios
    graceful_shutdown "exploit completed successfully" 10
}

# Function to handle error-based shutdown
error_shutdown() {
    local error_reason="$1"
    
    log_message "ERROR" "Error-based shutdown triggered: $error_reason"
    show_shutdown_status "error" "System error detected - initiating shutdown"
    
    # Minimal delay for error scenarios
    graceful_shutdown "error: $error_reason" 3
}

# Signal handlers
trap 'log_message "INFO" "Shutdown cancelled by user"; exit 0' INT TERM

# Main function
main() {
    local shutdown_type="${1:-graceful}"
    local shutdown_reason="${2:-manual shutdown}"
    local shutdown_delay="${3:-10}"
    
    # Create shutdown log
    touch "$SHUTDOWN_LOG"
    
    log_message "INFO" "Secure shutdown script started"
    log_message "INFO" "Shutdown type: $shutdown_type"
    log_message "INFO" "Shutdown reason: $shutdown_reason"
    
    # Check if auto shutdown is enabled
    if [ "$AUTO_SHUTDOWN" != "true" ] && [ "$shutdown_type" != "force" ]; then
        log_message "INFO" "Auto shutdown is disabled - exiting"
        show_shutdown_status "info" "Auto shutdown is disabled"
        exit 0
    fi
    
    case "$shutdown_type" in
        "success")
            success_shutdown
            ;;
        "error")
            error_shutdown "$shutdown_reason"
            ;;
        "timeout")
            timeout_shutdown "$shutdown_reason"
            ;;
        "emergency")
            emergency_shutdown
            ;;
        "graceful"|*)
            graceful_shutdown "$shutdown_reason" "$shutdown_delay"
            ;;
    esac
}

# Execute main function with all arguments
main "$@"